You receive a selection in neovim that you need to replace with new code.
The selection's contents may contain notes, incorporate the notes every time if there are some.
consider the context of the selection and what you are suppose to be implementing
<SELECTION_LOCATION>
range(point(128,1),point(166,1))
</SELECTION_LOCATION>
<SELECTION_CONTENT>
export const editStudent = async (req: Request, res: Response) => {
  try {
    if (!req.body || Object.entries(req.body).length === 0) throw new ApiError(400, "BAD_REQUEST", "Request body cannot be empty");

    const {
      id,
      phoneNumber,
      firstName,
      lastName,
      dateOfBirth,
      image

    } = req.body;

    interface StudentRequestBody {
      phoneNumber: string,
      firstName: string,
      lastName: string,
      dateOfBirth: string,
    };

    const requiredFileds = { id, phoneNumber, firstName, lastName, dateOfBirth } as StudentRequestBody;

    checkInput(requiredFileds);

  } catch (error) {
    if (error instanceof ApiError) {
      return res.status(error.status).json({
        code: error.code,
        message: error.message,
        details: error.stack
      });
    }
    return res.status(500).json({
      code: "INTERNAL_SERVER_ERROR",
      message: "Unexpected error, try again"
    });
  }

</SELECTION_CONTENT>
<FILE_CONTAINING_SELECTION>
import { Request, Response} from "express";
import { ApiError } from "../utils/ApiError";
import { checkInput } from "../utils/checkReq";
import { prisma } from '../db/prisma';
import { encrypt } from "../services/auth.service";

export const registerStudent = async (req: Request, res: Response) => {
  try {
    if (!req.body || Object.entries(req.body).length === 0) throw new ApiError(400, "BAD_REQUEST", "Request body cannot be empty");
    const {
      firstName,
      lastName,
      dateOfBirth,
      phoneNumber,
      coachId,
      image,
    } = req.body;

    interface registerStudentBody {
      firstName: string,
      lastName: string,
      dateOfBirth: string,
      phoneNumber:string,
      coachId: number
    }

    const requiredFileds = { firstName, lastName, dateOfBirth, phoneNumber, coachId } as registerStudentBody;
    checkInput(requiredFileds);

    const { mimeType, size, filename, url } = image ?? {};

    const phoneEnc = encrypt(phoneNumber);

    const existingUser = await prisma.student.findUnique({
      where: { phoneNumber: phoneEnc },
    });

    if (existingUser) {
      throw new ApiError(409, "CONFLICT", "User already exists");
    }

    const dateConverted = new Date(dateOfBirth);

    const coach = await prisma.user.findUnique({
      where: { id: coachId },
    });

    if (!coach) throw new ApiError(404, "NOT_FOUND", `Coach with ID: ${coachId} not exists`); 

    await prisma.student.create({
      data: {
        firstName: firstName,
        lastName: lastName,
        dateOfBirth: dateConverted,
        phoneNumber: phoneEnc,
        ...(image && {
          photos: {
            create: [
              {
                mimeType: mimeType,
                size: size,
                filename: filename,
                url: url,
              },
            ],
          },
        }),
        coach: {
          connect: { id: coach.id },
        },
      },
    });

    res.status(201).json({
      code: "CREATED",
      message: "Student created successfully"
    });
  } catch (error) {
    if (error instanceof ApiError) {
      return res.status(error.status).json({
        code: error.code,
        message: error.message,
        details: error.details
      });
    }
    console.error(error);
    return res.status(500).json({ error: "Internal server error" });
  }
};

export const deleteStudent = async (req: Request, res: Response) => {
  try {
    const studentId = Number(req.params.id);

    if (Number.isNaN(studentId)) {
      throw new ApiError(400, "BAD_REQUEST", "Student id must be a number");
    };

    if (!studentId) throw new ApiError(400, "BAD_REQUEST", "Sutdent id must be set");

    const studentExists = await prisma.student.findUnique({
      where: { id: studentId }
    });

    if (!studentExists) throw new ApiError(404, "NOT_FOUND", "Student not exists"); 

    await prisma.student.delete({
      where: { id: studentExists.id },
    });

    return res.status(200).json({
      code: "SUCCESS",
      message: "Student deleted successfully"
    });
  } catch (error) {
    if (error instanceof ApiError) {
      return res.status(error.status).json({
        code: error.code,
        message: error.message,
        details: error.details
      });
    }
    return res.status(500).json({ message: "Internal server error" });
  }
};

//TODO: Complete editStudent controller
export const editStudent = async (req: Request, res: Response) => {
  try {
    if (!req.body || Object.entries(req.body).length === 0) throw new ApiError(400, "BAD_REQUEST", "Request body cannot be empty");

    const {
      id,
      phoneNumber,
      firstName,
      lastName,
      dateOfBirth,
      image

    } = req.body;

    interface StudentRequestBody {
      phoneNumber: string,
      firstName: string,
      lastName: string,
      dateOfBirth: string,
    };

    const requiredFileds = { id, phoneNumber, firstName, lastName, dateOfBirth } as StudentRequestBody;

    checkInput(requiredFileds);

  } catch (error) {
    if (error instanceof ApiError) {
      return res.status(error.status).json({
        code: error.code,
        message: error.message,
        details: error.stack
      });
    }
    return res.status(500).json({
      code: "INTERNAL_SERVER_ERROR",
      message: "Unexpected error, try again"
    });
  }
};
</FILE_CONTAINING_SELECTION>

<MustObey>
NEVER alter any file other than TEMP_FILE.
never provide the requested changes as conversational output. Return only the code.
ONLY provide requested changes by writing the change to TEMP_FILE

never attempt to read TEMP_FILE.  It is purely for output.  Previous contents, which may not exist, can be written over without worry
</MustObey>
<TEMP_FILE>/home/misato/Work/sports_school_backend/tmp/99-7865</TEMP_FILE>